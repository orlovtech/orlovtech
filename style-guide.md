## Laravel & PHP Style Guide

⬆️ [Вернуться на главную](/README.md)

- [Основные правила](#основные-правила)
  - [Общие рекомендации по настройке окружения](#общие-рекомендации-по-настройке-окружения)
- [Именование сущностей](#именование-сущностей)
- [Правила размещения кода](#правила-размещения-кода)
  - [Бизнес логика в сервис-классах]()
  - [Сервисы](#сервисы)
  - [Контроллеры](#контроллеры)
  - [Модели](#модели)
- [Базовые правила](#базовые-правила)
  - [Тайпхинты](#тайпхинты)
  - [Комментарии и докблоки](#комментарии-и-докблоки)
  - [Нэйминг](#нэйминг)
  - [Enum](#enum)
  - [Области видимости](#области-видимости)
  - [Размеры классов, методов и вложенность](#размеры-классов-методов-и-вложенность)
  - [Избегайте else](#избегайте-else)
  - [DI по умолчанию в конструкторе](#di-по-умолчанию-в-конструкторе)
  - [Приоритет инстансов над статическими вызовами](#приоритет-инстансов-над-статическими-вызовами)
  - [Неиспользуемый код и следы отладки](#неиспользуемый-код-и-следы-отладки)
  - [Использование глобальных переменных](#использование-глобальных-переменных)
  - [Запрет на определение переменных в выражениях](#запрет-на-определение-переменных-в-выражениях)
  - [Использование параметров из env()](#использование-параметров-из-env)
  - [Тесты](#тесты)
  - [Логические операции сравнения](#логические-операции-сравнения)
  - [Happy path](#happy-path)
  - [Блоки try-catch](#блоки-try-catch)
- [Прочие рекомендации и предложения (для будущего разбора и описания)](#прочие-рекомендации-и-предложения-для-будущего-разбора-и-описания)

## Основные правила
Стиль написания кода должен следовать стандарту [PSR-12](https://www.php-fig.org/psr/psr-12/).

Минимальная настройка в [PhpStorm](https://blog.jetbrains.com/phpstorm/2019/11/phpstorm-2019-3-release/#psr), 
форматировать можно путём выделения куска кода (или всего скрипта) и нажатием горячих клавиш.

Здесь есть вся информация по использованию [автоформаттера CS Fixer](docs/cs-fixer.md)

### Общие рекомендации по настройке окружения
В своей IDE необходимо учитывать следующие параметры:
- используется кодировка `UTF-8 без BOM`
- перенос строки `LF` (для PhpStorm: Settings – Editor – Code Style – Line separator выставить в Unix and macOS (\n))
- глубина отступов до `120` символов (для PhpStorm: Settings – Editor – Code Style – Hard wrap at)

## Именование сущностей
Рекомендуется следовать соглашениям об именовании, принятым сообществом Laravel

Что | Правило                                                                   | Хорошо                                  | Плохо
------------ |---------------------------------------------------------------------------|-----------------------------------------| -------------
Контроллер | ед. ч.                                                                    | ArticleController                       | ~~ArticlesController~~
Маршруты | мн. ч.                                                                    | articles/1                              | ~~article/1~~
Маршруты | kebab-case                                                                | hr-candidates                           | ~~hr_candidates~~
Имя маршрута | snake_case с точечной нотацией                                            | users.show_active                       | ~~users.show-active, show-active-users~~
Модель | ед. ч.                                                                    | User                                    | ~~Users~~
Отношения hasOne и belongsTo | ед. ч.                                                                    | articleComment                          | ~~articleComments, article_comment~~
Все остальные отношения | мн. ч.                                                                    | articleComments                         | ~~articleComment, article_comments~~
Таблица | мн. ч.                                                                    | article_comments                        | ~~article_comment, articleComments~~
Pivot таблица | ед. ч. имена моделей в алфавитном порядке                                 | article_user                            | ~~user_article, articles_users~~
Столбец в таблице | snake_case без имени модели                                               | meta_title                              | ~~MetaTitle; article_meta_title~~
Свойство модели | snake_case                                                                | $model->created_at                      | ~~$model->createdAt~~
Миграция | -                                                                         | 2017_01_01_000000_create_articles_table | ~~2017_01_01_000000_articles~~
Метод | camelCase                                                                 | getAll                                  | ~~get_all~~
Метод в тесте | camelCase                                                                 | testGuestCannotSeeArticle               | ~~test_guest_cannot_see_article~~
Переменные | camelCase                                                                 | $articlesWithAuthor                     | ~~$articles_with_author~~
Коллекция | описательное, мн. ч.                                                      | $activeUsers = User::active()->get()    | ~~$active, $data~~
Объект | описательное, ед. ч.                                                      | $activeUser = User::active()->first()   | ~~$users, $obj~~
Представление | kebab-case                                                                | show-filtered.blade.php                 | ~~showFiltered.blade.php, show_filtered.blade.php~~
Конфиг-файл | kebab-case                                                                | google-calendar.php                     | ~~googleCalendar.php, google_calendar.php~~
Контракт (интерфейс) | прилагательное или существительное                                        | AuthenticationInterface                 | ~~Authenticatable, IAuthentication~~
Трейт | прилагательное                                                            | Notifiable                              | ~~NotificationTrait~~

## Правила размещения кода

### Бизнес логика в сервис-классах
Контроллер, модель, blade-шаблон, консольная команда, джоба, должны выполнять только свои прямые обязанности, они не должны содержать никаких вычислений и прочей бизнес-логики, 
всё это необходимо выносить в отдельные сервис классы (`app\Services\`).

### Сервисы
Сервис – это класс без состояния, содержащий бизнес-логику. Данные для обработки сервис получает либо в виде параметров публичных методов, либо других сервисов.
Сервисы можно использовать в контроллерах, джобах, консольных командах, трейтах и т.д. Сервисы нельзя использовать в моделях.

### Контроллеры
Контроллер принимает и обрабатывает запросы. Он получает параметры на вход, запрашивает данные из сервисов и возвращает представление либо json-объект.

### Модели
Модель — простой объект с методами, не содержащий никакой другой бизнес-логики, кроме связей с другими методами, геттеров, читателей (accessors), преобразователей (mutators) скоупов, атрибутов.

В моделях нельзя инстанцировать сервис-контроллеры. 

## Базовые правила
### Тайпхинты
Если метод ничего не возвращает, он должен быть обозначен как `:void`. В иных случаях необходимо явно указать тип параметров и ожидаемое возвращаемое значение.

Для всех новых классов рекомендуется указание 
```php
declare(strict_types=1);
```
В случае рефакторинга старого класса и полной уверенности в том, что все методы содержат тайпхинты и тесты не падают, также можно добавить этот параметр.

### Комментарии и докблоки
Следует избегать бессмысленных, автосгенерированных комментариев. В том числе, если они содержат только определение параметров и возаращаемых значений, такие докблоки нужно заменить на тайпхинты.

```php
// Хорошо
class Url
{
    public static function fromString(string $url): Url
    {
        // ...
    }
}

// Плохо: Описание является избыточным, название метода говорящее и есть тайпхинты
class Url
{
    /**
     * Create a url from a string.
     *
     * @param string $url
     *
     * @return \ISomeClass\Url\Url
     */
    public static function fromString(string $url): Url
    {
        // ...
    }
}
```

Если используется описательный комментарий и когда это возможно, следует писать его в одну строку

```php
// Хорошо

/** @var string */
/** @test */

// Плохо

/**
 * @test
 */
```

При этом если функционал содержил сложную логику (например калькуляторы), необходимо добавлять комментарии с описанием процесса.

### Нэйминг
Давать понятные и говорящие названия переменным, классам, методам. Основные принципе:
- используйте значимые и произносимые имена переменных
- используйте имена, по которым удобно искать (например булевы методы или переменные называть сразу с указанием `isAuthorized()`)

В случаях, когда это возможно, не использовать транслит.

В ряде классов необходимо использовать указывающие на принадлежность окончания:
- Controller
- Service
- Command
- Request
- Job
- Resource
- Event
- Listener
- Mail

### Enum

Вместо использования констант в любых сущностях нужно использовать Enum (`app\Enums`). При рефакторинге старого кода
также стараться переносить константы туда.

### Пример с использованием MyCLabs\Enum оставлен для понимания легаси. При написании нового кода необходимо использовать [встроенные в язык перечисления](https://www.php.net/manual/en/language.enumerations.php)

Самый простой вариант enum-класса

```php
<?php
namespace App\Enums;

use MyCLabs\Enum\Enum;

class PostStatus extends Enum
{
    public const DRAFT = 'draft';
    public const PUBLISHED = 'published';
}
```

Использовать:
```php
PostStatus::DRAFT;
```

Также можно сделать константы приватными и пользоваться только методами. 
В случае вызова публичной константы, вы получаете сразу значение. 
В случае вызова через метод, вы получаете объект енама. Этот объект уже можно тайпхинтить в свойства классов и методов.

Можно расширить, добавлением несложной логики:
1. добавить статические методы в докблоке
2. добавить метод с перечислением вариантов

```php
use MyCLabs\Enum\Enum;

/**
 * @method static self DRAFT()
 * @method static self PUBLISHED()
 */
class PostStatus extends Enum
{
    private const DRAFT = 'draft';
    private const PUBLISHED = 'published';

    public function color(): string
    {
        switch ($this->value) {
            case self::DRAFT()->value:
                return "bg-red-500";
            case self::PUBLISHED()->value:
                return "bg-green-500";
            default:
                return "bg-gray-500";
        }
    }
}
```

Использовать:
```php
PostStatus::DRAFT()->color();
```

### Области видимости
Для методов, свойств видимость по умолчанию — `private`. Все методы внутри класса, которые не должны быть видны снаружи, необходимо делать приватными.

### Размеры классов, методов и вложенность
- Не используйте слишком длинные классы и методы. Один метод должен решать только одну задачу. Один класс должен решать только один концепт
- Декомпозируйте метод на несколько маленьких, связанных, если вы видите, что он разрастается
- Не используйте большое количество передаваемых в метод атрибутов (допускается 1-3)
- Не используйте большое количество инстанцируемых классов внутри конструктора (допускается не больше 5)
- Рекомендуется отказаться от длинных тернарных операторов

### Избегайте else
Рекомендуется отказаться от глубоких вложений if-else. По возможности используйте паттерн early return, при котором вы проверяете допустимый стейт и сразу возвращаете ответ


```php
// Хорошо

if (!$conditionA) {
   // условие A неуспешно
   
   return;
}

if (!$conditionB) {
   // условие B неуспешно
   
   return;
}

// условие А и B прошло
```

```php
// Плохо

if ($conditionA) {
   if ($conditionB) {
      // условие A и B прошло
   } else {
     // условие A пррошло B нет
   }
} else {
   // условие А не прошло
}
```

### DI по умолчанию в конструкторе
Все классы необходимо определять в конструкторе. 
В случае, если конструктор подключаемого класса требует передачу параметров, его нужно определить в провайдере, если не получается через провайдер, 
[сделать через метод](https://laravel.com/docs/9.x/container#the-make-method)
```php
$this->app->make(SomeClass::class);
```

### Приоритет инстансов над статическими вызовами
Везде где это возможно, нужно использовать вызов методов через инстанцирование, а не через статический вызов метода.

### Неиспользуемый код и следы отладки
Весь неиспользуемый (закомментированный, старый) код нужно удалять. В том числе рекомендуется удалить:
- пустые методы
- `dd()`, принты и прочие `echo`
В том случае, если код закомментирован намеренно и на короткий срок (например фиа скрыта по просьбе бизнеса), рекомендуется оставить комментарий или `TODO` пометку

### Использование глобальных переменных
Нельзя использовать глобальные или суперглобальные переменные (`$_SERVER`, `$_GLOBAL` и тд).

### Запрет на определение переменных в выражениях
Не допускается использование определения переменной внутри условия if. Необходимо вынести такое определение выше условия.

```php
// Хорошо

$data = Model::all();

if ($data->get()) {
    // do your staff
}
```

```php
// Плохо

if ($data = Model::all()->get()) {
    // do your staff
}
```

### Использование параметров из env()
Рекомендуется избегать использования env() вне файла конфигураций. Если нужно что-то достать из env файла, создаёте параметр в файле конфигураций (например `/configuration/services.php`) и используйте его через метод `config()`.

Для определения окружения рекомендуется использовать метод `app()->environment()`

```php
// Хорошо

if (app()->environment(['stage','testing'])) {
    // do your staff
}

// или

if (app()->environment('stage')) {
    // do your staff
}
```

```php
// Плохо

if (in_array(env('APP_ENV'), ['stage','testing'])) {
    // do your staff
}
```

### Тесты
При написании тестов рекомендуется следовать следующим правилам:
- методы в тестах должны быть разбиты на логические концепции, одна тестируемая концепция – один метод
- имена для тестов должны даваться понятные
- в окончании имени теста использовать `Success/Fail` где это необходимо
- тесты джоб, консолей, миддлваров и т.д. должны выноситься в отдельные директории. Например: `tests/Jobs`, `tests/Console` и т.д.

### Логические операции сравнения
Используйте строгое сравнение `!==`, `===` вместо `!=`, `==`

### Happy path
Все булевы сравнения должны начинаться с проверки отрицания. В этом блоке проверки выкидывается эксепшен или return.
После блока с отрицанием продолжается работа с методом.

```php
if (!$goodCondition) {
  throw new Exception;
}

// продолжение работы
```

### Блоки try-catch

Не допускается использование пустых блоков `catch`. Если такой блок есть, как минимум он должен выполнять логирование
ошибки.

### Использование классов вместо массивов

Для структур данных необходимо использовать классы вместо ассоциативных массивов

```php
// ок

class UserFullName
{
    public function __construct(
        public readonly string $firstName,
        public readonly string $secondName,
        public readonly string $patronymic,
    ) {
    }
}

function getUserFullName(): UserFullName
{
    /* ... */
    
    return new UserFullName($firstName, $secondName, $patronymic)
}
```

```php
// не ок

function getUserCredentials(): array 
{
    return [
        'firstName' => $firstName,
        'secondName' => $secondName,
        'patronymic' => $patronymic,
    ]
}
```

Допустимо использование массивов для однородных данных с указанием типа в аннотациях

```php
/**
* @return UserFullName[]
*/
function getUserFullNameList(): array
{
    /* ... */
    
    return [
        new UserFullName($firstName1, $secondName1, $patronymic1),
        new UserFullName($firstName2, $secondName2, $patronymic2),
    ]
}
```

Так же и для многоуровневых структур

```php
class User
{
    public function __construct(
        public UserFullName $fullName,
        public string $email,
    ) {
    }
}
```

#### Возможная проблема:

Нет возможности переписать с ассоциативного массива на класс потому что метод много где используется

#### Решение:

Может помочь [интерфейс ArrayAccess](https://www.php.net/manual/en/class.arrayaccess.php). В особо сложных случаях можно
хотя бы описать структуру с
помощью [атрибута ArrayShape](https://blog.jetbrains.com/phpstorm/2020/10/phpstorm-2020-3-eap-4/#arrayshape)

## Прочие рекомендации и предложения (для будущего разбора и описания)

- Отказ от неявных вызовов вида $object->$property
- Функция должна возвращать только одну переменную
- Не использовать подавление ошибок “@”
- Отвязывать анонимные от контекста если в этом нет необходимости ([почитать](https://habr.com/ru/post/561550/))
- Отбивать пустой строкой return и throw, если перед ними есть какой-либо код
